var pbjs = require("protobufjs")
var fs = require("fs")

function hash_code(str) {
    var h = 0;
    var len = str.length;
    var t = 2147483648;
    for (var i = 0; i < len; i++) {
        h = 31 * h + str.charCodeAt(i);
        if (h > 2147483647) h %= t; //java int溢出则取模
    }
    /*var t = -2147483648 * 2;
     while (h > 2147483647) {
     h += t
     }*/
    return h;
}

function get_protocol_id(package, name) {
    // console.log("package.cache = ", package.cache)
    let entry = package.cache[name]
    if (!!entry) {
        // console.log(name, "use cached id", entry.id)
        return entry.id
    }
    let unique_id = 1
    for (let key in package.cache) {
        let obj = package.cache[key]
        // console.log("iterate", obj)
        if (obj.id >= unique_id) {
            unique_id++
        } 
    }
    package.cache[name] = {
        id: unique_id, 
    }
    return unique_id
}

function collect_protocols(package, protocols, protofile, prefix) {
    // var auto_id = 1
    var proto = pbjs.loadSync(protofile) // "../../proto/king.proto"
    for (var topIndex in proto.nestedArray) {
        var top = proto.nestedArray[topIndex]
        package.name = top.name
        console.log("package: " + top.name)
        for (var itemIndex in top) {
            var msg = top[itemIndex]
            if (msg instanceof pbjs.Type) {
                if (!prefix || msg.name.startsWith(prefix)) {
                    // var id_field = msg.fields["id"]
                    var name = msg.name
                    // var msg_id = new msg.ctor().id
                    let auto_id = get_protocol_id(package, msg.name)
                    console.log(msg.name + ":" + auto_id)
                    protocols[msg.name] = auto_id
                    // console.log(id_field + ":" + id_field.defaultValue)
                    auto_id++
                }
            } else if (msg instanceof pbjs.Namespace) {
                // console.log(msg + " (namespace)")
            } else if (msg instanceof pbjs.Root) {
                // console.log(msg + " (root)")
            } else {
                // console.log(typeof(msg) + " (unrecognized)")
            }
        }
    }
}

function gen_proto_lua_map(package, protocols, outfile) {
    var fd = fs.openSync(outfile, "w")

    fs.writeSync(fd, 'return { -- generated by node\n')
    fs.writeSync(fd, `    ["magic"] = ${package.hash},\n`)
    fs.writeSync(fd, `    ["maxPayloadSize"] = ${package.maxPayloadSize},\n`)
    for (var name in protocols) {
        let msg_id = protocols[name]
        fs.writeSync(fd, `    [${package.name}.${name}] = ${msg_id},`)
        fs.writeSync(fd, `[${msg_id}] = ${package.name}.${name},\n`)
    }
    fs.writeSync(fd, '}')
    fs.closeSync(fd)
}

function gen_proto_go_map(package, protocols, outfile) {
    var fd = fs.openSync(outfile, "w")

    fs.writeSync(fd, `package ${package.name} // auto generated by node, do not modify it manually!\n`)
    fs.writeSync(fd, `import "${package.go_package}"\n`)
    fs.writeSync(fd, `
var ${package.export} = network.NewProtocols(${package.hash}, ${package.maxPayloadSize})

`)
    fs.writeSync(fd, 'func init() {\n')
    for (var name in protocols) {
        let msg_id = protocols[name]
        fs.writeSync(fd, `    ${package.export}.Register(${msg_id}, (*${name})(nil))\n`)
    }
    fs.writeSync(fd, '}')
    fs.closeSync(fd)
}

function gen_proto_ts_map(package, protocols, outfile) {
    var fd = fs.openSync(outfile, "w")

    fs.writeSync(fd, `class ${package.name}_register {  // auto generated by node, do not modify it manually!\n`)
    fs.writeSync(fd, '    static reg() {\n')
    fs.writeSync(fd, `        ${package.export}.magic = ${package.hash}\n`)
    fs.writeSync(fd, `        ${package.export}.maxPayloadSize = ${package.maxPayloadSize}\n`)
    for (var name in protocols) {
        let msg_id = protocols[name]
        fs.writeSync(fd, `        ${package.export}.register(${msg_id}, ${package.name}.${name})\n`)
    }
    fs.writeSync(fd, '    }\n')
    fs.writeSync(fd, '}\n')
    fs.closeSync(fd)
}

let package = {
    cache: {}, // 协议缓存 (保持每次生成协议id不变)
    cachePath: null,
    message_size: 2,
    session_size: 4,
    go_package: "github.com/ialex32x/sgless/network",
    export: "Protocols",
    maxPayloadSize: 1024 * 64,
    hash: hash_code((Math.random() * 999999999).toString() + new Date().toISOString()),
}
let protocols = {}

for (var i = 2; i < process.argv.length; i++) {
    var argv = process.argv[i]
    if (argv.startsWith("--session=")) {
        package.session_size = parseInt(argv.split("=")[1])
    } else if (argv.startsWith("--message=")) {
        package.message_size = parseInt(argv.split("=")[1])
    } else if (argv.startsWith("--export=")) {
        package.export = argv.split("=")[1]
    } else if (argv.startsWith("--cache=")) {
        // 协议 id 缓存
        package.cachePath = argv.split("=")[1]
        try {
            if (fs.existsSync(package.cachePath)) {
                let cacheBuf = fs.readFileSync(package.cachePath)
                package.cache = JSON.parse(cacheBuf.toString()) || {}
                // console.log("load protocol cache", package.cache)
            }
        } catch (err) {
            console.log("invalid cache, ", err)
        }
    }
}

for (var i = 2; i < process.argv.length; i++) {
    var protofile = process.argv[i]
    if (protofile.endsWith(".proto")) {
        // collect_protocols(protocols, protofile, "MSG_")
        collect_protocols(package, protocols, protofile, null)
    }
}

function save_protocols_cache(package) {
    if (!!package.cachePath) {
        fs.writeFileSync(package.cachePath, JSON.stringify(package.cache, null, "\t"))
    }
}

save_protocols_cache(package)

for (var i = 2; i < process.argv.length; i++) {
    var argv = process.argv[i]
    if (argv.endsWith(".lua")) {
        gen_proto_lua_map(package, protocols, argv)
    } else if (argv.endsWith(".go")) {
        gen_proto_go_map(package, protocols, argv)
    } else if (argv.endsWith(".ts")) {
        gen_proto_ts_map(package, protocols, argv)
    }
}
